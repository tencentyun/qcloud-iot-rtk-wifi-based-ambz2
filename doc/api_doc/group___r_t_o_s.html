<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SDK7.1: RTOS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDK7.1
   </div>
   <div id="projectbrief">This document shows Ameba SDK 7.1 APIs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RTOS<div class="ingroups"><a class="el" href="group__sdk.html">Ameba SDK</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>RTOS functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtimer__list.html">timer_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtask__struct.html">task_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtw__worker__thread__t.html">rtw_worker_thread_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtw__event__message__t.html">rtw_event_message_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structworker__timer__entry.html">worker_timer_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwork__struct.html">work_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdelayed__work.html">delayed_work</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmem__entry.html">mem_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosdep__service__ops.html">osdep_service_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9f8235595e6f9b556f30025bcc149f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga9f8235595e6f9b556f30025bcc149f21">init_mem_monitor</a> (_list *pmem_table, int *used_num)</td></tr>
<tr class="memdesc:ga9f8235595e6f9b556f30025bcc149f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a memory table.  <a href="#ga9f8235595e6f9b556f30025bcc149f21">More...</a><br /></td></tr>
<tr class="separator:ga9f8235595e6f9b556f30025bcc149f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37363e084632199f1870b3105a7dc454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga37363e084632199f1870b3105a7dc454">deinit_mem_monitor</a> (_list *pmem_table, int *used_num)</td></tr>
<tr class="memdesc:ga37363e084632199f1870b3105a7dc454"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deinitializes a memory table.  <a href="#ga37363e084632199f1870b3105a7dc454">More...</a><br /></td></tr>
<tr class="separator:ga37363e084632199f1870b3105a7dc454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8fba4d853a4b5981aaaa0e37cdae7de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaa8fba4d853a4b5981aaaa0e37cdae7de">add_mem_usage</a> (_list *pmem_table, void *ptr, int size, int *used_num, int flag)</td></tr>
<tr class="memdesc:gaa8fba4d853a4b5981aaaa0e37cdae7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function alloc <a class="el" href="structmem__entry.html">mem_entry</a> to the memory table.  <a href="#gaa8fba4d853a4b5981aaaa0e37cdae7de">More...</a><br /></td></tr>
<tr class="separator:gaa8fba4d853a4b5981aaaa0e37cdae7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf74d3a405d503e2465988dffa6f1a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gadf74d3a405d503e2465988dffa6f1a64">del_mem_usage</a> (_list *pmem_table, void *ptr, int *used_num, int flag)</td></tr>
<tr class="memdesc:gadf74d3a405d503e2465988dffa6f1a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees memory from the memory table.  <a href="#gadf74d3a405d503e2465988dffa6f1a64">More...</a><br /></td></tr>
<tr class="separator:gadf74d3a405d503e2465988dffa6f1a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56f111283bb33a374b7d4d0bc1c94c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaa56f111283bb33a374b7d4d0bc1c94c2">get_mem_usage</a> (_list *pmem_table)</td></tr>
<tr class="memdesc:gaa56f111283bb33a374b7d4d0bc1c94c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the memory usage of a memory table.  <a href="#gaa56f111283bb33a374b7d4d0bc1c94c2">More...</a><br /></td></tr>
<tr class="separator:gaa56f111283bb33a374b7d4d0bc1c94c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5627853bef70ebbcccb913093b2a3c3"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gae5627853bef70ebbcccb913093b2a3c3">rtw_vmalloc</a> (u32 sz)</td></tr>
<tr class="memdesc:gae5627853bef70ebbcccb913093b2a3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates the virtually contiguous memory.  <a href="#gae5627853bef70ebbcccb913093b2a3c3">More...</a><br /></td></tr>
<tr class="separator:gae5627853bef70ebbcccb913093b2a3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2cd73358028cae5a8c9970bfe41b996"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaa2cd73358028cae5a8c9970bfe41b996">rtw_zvmalloc</a> (u32 sz)</td></tr>
<tr class="memdesc:gaa2cd73358028cae5a8c9970bfe41b996"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates the virtually contiguous memory and the values of the memory are setted to 0.  <a href="#gaa2cd73358028cae5a8c9970bfe41b996">More...</a><br /></td></tr>
<tr class="separator:gaa2cd73358028cae5a8c9970bfe41b996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510c5826df487b958b88a22574cc0e53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga510c5826df487b958b88a22574cc0e53">rtw_vmfree</a> (u8 *pbuf, u32 sz)</td></tr>
<tr class="memdesc:ga510c5826df487b958b88a22574cc0e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the virtually contiguous memory.  <a href="#ga510c5826df487b958b88a22574cc0e53">More...</a><br /></td></tr>
<tr class="separator:ga510c5826df487b958b88a22574cc0e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40bfe4cd4df674a0b6c8ada337314885"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga40bfe4cd4df674a0b6c8ada337314885">rtw_zmalloc</a> (u32 sz)</td></tr>
<tr class="memdesc:ga40bfe4cd4df674a0b6c8ada337314885"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates the memory and the values of the memory are setted to 0.  <a href="#ga40bfe4cd4df674a0b6c8ada337314885">More...</a><br /></td></tr>
<tr class="separator:ga40bfe4cd4df674a0b6c8ada337314885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38480df2657a06473435aebecf3f0f0"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gac38480df2657a06473435aebecf3f0f0">rtw_malloc</a> (u32 sz)</td></tr>
<tr class="memdesc:gac38480df2657a06473435aebecf3f0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates the memory.  <a href="#gac38480df2657a06473435aebecf3f0f0">More...</a><br /></td></tr>
<tr class="separator:gac38480df2657a06473435aebecf3f0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210903829e249ee36ebbae895fdfeb68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga210903829e249ee36ebbae895fdfeb68">rtw_mfree</a> (u8 *pbuf, u32 sz)</td></tr>
<tr class="memdesc:ga210903829e249ee36ebbae895fdfeb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the virtually contiguous memory.  <a href="#ga210903829e249ee36ebbae895fdfeb68">More...</a><br /></td></tr>
<tr class="separator:ga210903829e249ee36ebbae895fdfeb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5cfcf0bfa0cf4d12b3140c927474a9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga7e5cfcf0bfa0cf4d12b3140c927474a9">rtw_malloc2d</a> (int h, int w, int size)</td></tr>
<tr class="memdesc:ga7e5cfcf0bfa0cf4d12b3140c927474a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates a 2 dimensional array memory.  <a href="#ga7e5cfcf0bfa0cf4d12b3140c927474a9">More...</a><br /></td></tr>
<tr class="separator:ga7e5cfcf0bfa0cf4d12b3140c927474a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b960a8744e7f4d12336cbcce554f10b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga9b960a8744e7f4d12336cbcce554f10b">rtw_mfree2d</a> (void *pbuf, int h, int w, int size)</td></tr>
<tr class="memdesc:ga9b960a8744e7f4d12336cbcce554f10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deallocates the block of memory previously allocated to make it available again.  <a href="#ga9b960a8744e7f4d12336cbcce554f10b">More...</a><br /></td></tr>
<tr class="separator:ga9b960a8744e7f4d12336cbcce554f10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b31fb541897d351bcf322467e7626ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga8b31fb541897d351bcf322467e7626ed">rtw_memcpy</a> (void *dst, void *src, u32 sz)</td></tr>
<tr class="memdesc:ga8b31fb541897d351bcf322467e7626ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the values of "sz" bytes from the location pointed to by "src" directly to the memory block pointed to by "des".  <a href="#ga8b31fb541897d351bcf322467e7626ed">More...</a><br /></td></tr>
<tr class="separator:ga8b31fb541897d351bcf322467e7626ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa049f0f8d4f7f3dc1dccaa7cab8b00e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaa049f0f8d4f7f3dc1dccaa7cab8b00e2">rtw_memcmp</a> (void *dst, void *src, u32 sz)</td></tr>
<tr class="memdesc:gaa049f0f8d4f7f3dc1dccaa7cab8b00e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares the first "sz" bytes of the block of memory pointed by "dst" to the first "sz" bytes pointed by "src".  <a href="#gaa049f0f8d4f7f3dc1dccaa7cab8b00e2">More...</a><br /></td></tr>
<tr class="separator:gaa049f0f8d4f7f3dc1dccaa7cab8b00e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5db16ab98682918647b010a65daf179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaa5db16ab98682918647b010a65daf179">rtw_memset</a> (void *pbuf, int c, u32 sz)</td></tr>
<tr class="memdesc:gaa5db16ab98682918647b010a65daf179"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the first "sz" bytes of the block of memory pointed by "pbuf" to the specified "c".  <a href="#gaa5db16ab98682918647b010a65daf179">More...</a><br /></td></tr>
<tr class="separator:gaa5db16ab98682918647b010a65daf179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3c7baf89d8fd411e5ed5dc9682c2ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga4e3c7baf89d8fd411e5ed5dc9682c2ba">rtw_init_listhead</a> (_list *list)</td></tr>
<tr class="memdesc:ga4e3c7baf89d8fd411e5ed5dc9682c2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the head of the list.  <a href="#ga4e3c7baf89d8fd411e5ed5dc9682c2ba">More...</a><br /></td></tr>
<tr class="separator:ga4e3c7baf89d8fd411e5ed5dc9682c2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfab29b24ba6eac2f7daf8a37946eed0"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gabfab29b24ba6eac2f7daf8a37946eed0">rtw_is_list_empty</a> (_list *phead)</td></tr>
<tr class="memdesc:gabfab29b24ba6eac2f7daf8a37946eed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether a list is empty.  <a href="#gabfab29b24ba6eac2f7daf8a37946eed0">More...</a><br /></td></tr>
<tr class="separator:gabfab29b24ba6eac2f7daf8a37946eed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804faac1fb48202fb596096d27679fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga804faac1fb48202fb596096d27679fbd">rtw_list_insert_head</a> (_list *plist, _list *phead)</td></tr>
<tr class="memdesc:ga804faac1fb48202fb596096d27679fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds a new entry after "phead" for the list.  <a href="#ga804faac1fb48202fb596096d27679fbd">More...</a><br /></td></tr>
<tr class="separator:ga804faac1fb48202fb596096d27679fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f342e747430bbf855b1b0f845bf9d87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga5f342e747430bbf855b1b0f845bf9d87">rtw_list_insert_tail</a> (_list *plist, _list *phead)</td></tr>
<tr class="memdesc:ga5f342e747430bbf855b1b0f845bf9d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds a new entry before "phead" for the list.  <a href="#ga5f342e747430bbf855b1b0f845bf9d87">More...</a><br /></td></tr>
<tr class="separator:ga5f342e747430bbf855b1b0f845bf9d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f1bf966f380681638ec580b709ee77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gad2f1bf966f380681638ec580b709ee77">rtw_list_delete</a> (_list *plist)</td></tr>
<tr class="memdesc:gad2f1bf966f380681638ec580b709ee77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes entry from list and reinitialize it.  <a href="#gad2f1bf966f380681638ec580b709ee77">More...</a><br /></td></tr>
<tr class="separator:gad2f1bf966f380681638ec580b709ee77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672f0efc2e47205a5379fe474e7a176b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga672f0efc2e47205a5379fe474e7a176b">rtw_init_sema</a> (_sema *sema, int init_val)</td></tr>
<tr class="memdesc:ga672f0efc2e47205a5379fe474e7a176b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the unnamed semaphore referred to by "sema" to the value "init_val".  <a href="#ga672f0efc2e47205a5379fe474e7a176b">More...</a><br /></td></tr>
<tr class="separator:ga672f0efc2e47205a5379fe474e7a176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38a2d622f9867e03a61245badd4a481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gae38a2d622f9867e03a61245badd4a481">rtw_free_sema</a> (_sema *sema)</td></tr>
<tr class="memdesc:gae38a2d622f9867e03a61245badd4a481"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes the semaphore.  <a href="#gae38a2d622f9867e03a61245badd4a481">More...</a><br /></td></tr>
<tr class="separator:gae38a2d622f9867e03a61245badd4a481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ec8c04aa355f3b8f793ab2bd203708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga96ec8c04aa355f3b8f793ab2bd203708">rtw_up_sema</a> (_sema *sema)</td></tr>
<tr class="memdesc:ga96ec8c04aa355f3b8f793ab2bd203708"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases the semaphore. This macro must not be used from an ISR.  <a href="#ga96ec8c04aa355f3b8f793ab2bd203708">More...</a><br /></td></tr>
<tr class="separator:ga96ec8c04aa355f3b8f793ab2bd203708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d38da5c99a8b7a89e101aee8ffd69b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga6d38da5c99a8b7a89e101aee8ffd69b9">rtw_up_sema_from_isr</a> (_sema *sema)</td></tr>
<tr class="memdesc:ga6d38da5c99a8b7a89e101aee8ffd69b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases the semaphore. This macro can be used from an ISR.  <a href="#ga6d38da5c99a8b7a89e101aee8ffd69b9">More...</a><br /></td></tr>
<tr class="separator:ga6d38da5c99a8b7a89e101aee8ffd69b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8866f237041311efe4a0096a901c82c6"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga8866f237041311efe4a0096a901c82c6">rtw_down_sema</a> (_sema *sema)</td></tr>
<tr class="memdesc:ga8866f237041311efe4a0096a901c82c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function acquires the semaphore. If no more tasks are allowed to acquire the semaphore, calling this function will put the task to sleep until the semaphore is up.  <a href="#ga8866f237041311efe4a0096a901c82c6">More...</a><br /></td></tr>
<tr class="separator:ga8866f237041311efe4a0096a901c82c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef950465b7b07566a08e6ae45803de5d"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaef950465b7b07566a08e6ae45803de5d">rtw_down_timeout_sema</a> (_sema *sema, u32 timeout)</td></tr>
<tr class="memdesc:gaef950465b7b07566a08e6ae45803de5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function acquires the semaphore. If no more tasks are allowed to acquire the semaphore, calling this function will put the task to sleep until the semaphore is up.  <a href="#gaef950465b7b07566a08e6ae45803de5d">More...</a><br /></td></tr>
<tr class="separator:gaef950465b7b07566a08e6ae45803de5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46eb1c50c29acf8e4052707ab51e768c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga46eb1c50c29acf8e4052707ab51e768c">rtw_mutex_init</a> (_mutex *pmutex)</td></tr>
<tr class="memdesc:ga46eb1c50c29acf8e4052707ab51e768c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements a mutex semaphore by using the existing queue mechanism.  <a href="#ga46eb1c50c29acf8e4052707ab51e768c">More...</a><br /></td></tr>
<tr class="separator:ga46eb1c50c29acf8e4052707ab51e768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2f29a11830cdc9030a91f6ed49f74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga0a2f29a11830cdc9030a91f6ed49f74a">rtw_mutex_free</a> (_mutex *pmutex)</td></tr>
<tr class="memdesc:ga0a2f29a11830cdc9030a91f6ed49f74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes the mutex semaphore.  <a href="#ga0a2f29a11830cdc9030a91f6ed49f74a">More...</a><br /></td></tr>
<tr class="separator:ga0a2f29a11830cdc9030a91f6ed49f74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61df40838863df72ef65ad766aee3fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga61df40838863df72ef65ad766aee3fa4">rtw_mutex_put</a> (_mutex *pmutex)</td></tr>
<tr class="memdesc:ga61df40838863df72ef65ad766aee3fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases a mutex semaphore.  <a href="#ga61df40838863df72ef65ad766aee3fa4">More...</a><br /></td></tr>
<tr class="separator:ga61df40838863df72ef65ad766aee3fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62acfe38de294d000720de79d20ea3e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga62acfe38de294d000720de79d20ea3e9">rtw_mutex_get</a> (_mutex *pmutex)</td></tr>
<tr class="memdesc:ga62acfe38de294d000720de79d20ea3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains a mutex semaphore.  <a href="#ga62acfe38de294d000720de79d20ea3e9">More...</a><br /></td></tr>
<tr class="separator:ga62acfe38de294d000720de79d20ea3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29651aa1be8c5cfaa8dcbecb5917bb3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga29651aa1be8c5cfaa8dcbecb5917bb3c">rtw_mutex_get_timeout</a> (_mutex *pmutex, u32 timeout_ms)</td></tr>
<tr class="memdesc:ga29651aa1be8c5cfaa8dcbecb5917bb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains a mutex semaphore with a timeout setting.  <a href="#ga29651aa1be8c5cfaa8dcbecb5917bb3c">More...</a><br /></td></tr>
<tr class="separator:ga29651aa1be8c5cfaa8dcbecb5917bb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ebf88345d437f95ac6db2534a9f3bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga25ebf88345d437f95ac6db2534a9f3bd">rtw_enter_critical</a> (_lock *plock, _irqL *pirqL)</td></tr>
<tr class="memdesc:ga25ebf88345d437f95ac6db2534a9f3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function marks the start of a critical code region. Preemptive context switches cannot occur when in a critical region.  <a href="#ga25ebf88345d437f95ac6db2534a9f3bd">More...</a><br /></td></tr>
<tr class="separator:ga25ebf88345d437f95ac6db2534a9f3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a8793d6348a9b8875163fd04961b38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gab0a8793d6348a9b8875163fd04961b38">rtw_exit_critical</a> (_lock *plock, _irqL *pirqL)</td></tr>
<tr class="memdesc:gab0a8793d6348a9b8875163fd04961b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function marks end of a critical code region. Preemptive context switches cannot occur when in a critical region.  <a href="#gab0a8793d6348a9b8875163fd04961b38">More...</a><br /></td></tr>
<tr class="separator:gab0a8793d6348a9b8875163fd04961b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b05366edfa20347cbd6501b9e77ec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gad8b05366edfa20347cbd6501b9e77ec9">rtw_enter_critical_from_isr</a> (_lock *plock, _irqL *pirqL)</td></tr>
<tr class="memdesc:gad8b05366edfa20347cbd6501b9e77ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function marks the start of a critical code region from isr.  <a href="#gad8b05366edfa20347cbd6501b9e77ec9">More...</a><br /></td></tr>
<tr class="separator:gad8b05366edfa20347cbd6501b9e77ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e735aa05f4c73300225a4b9ccb2bfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga58e735aa05f4c73300225a4b9ccb2bfa">rtw_exit_critical_from_isr</a> (_lock *plock, _irqL *pirqL)</td></tr>
<tr class="memdesc:ga58e735aa05f4c73300225a4b9ccb2bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function marks the end of a critical code region from isr.  <a href="#ga58e735aa05f4c73300225a4b9ccb2bfa">More...</a><br /></td></tr>
<tr class="separator:ga58e735aa05f4c73300225a4b9ccb2bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c65ec3e920cf2096815d65cb73c417c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga3c65ec3e920cf2096815d65cb73c417c">rtw_enter_critical_bh</a> (_lock *plock, _irqL *pirqL)</td></tr>
<tr class="memdesc:ga3c65ec3e920cf2096815d65cb73c417c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains a spin lock semaphore.  <a href="#ga3c65ec3e920cf2096815d65cb73c417c">More...</a><br /></td></tr>
<tr class="separator:ga3c65ec3e920cf2096815d65cb73c417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098121bd2ccffdb029660cab44ebeede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga098121bd2ccffdb029660cab44ebeede">rtw_exit_critical_bh</a> (_lock *plock, _irqL *pirqL)</td></tr>
<tr class="memdesc:ga098121bd2ccffdb029660cab44ebeede"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases a spin lock semaphore.  <a href="#ga098121bd2ccffdb029660cab44ebeede">More...</a><br /></td></tr>
<tr class="separator:ga098121bd2ccffdb029660cab44ebeede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24f292f35f2f61373ff4727e42786a0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga24f292f35f2f61373ff4727e42786a0d">rtw_enter_critical_mutex</a> (_mutex *pmutex, _irqL *pirqL)</td></tr>
<tr class="memdesc:ga24f292f35f2f61373ff4727e42786a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains a semaphore.  <a href="#ga24f292f35f2f61373ff4727e42786a0d">More...</a><br /></td></tr>
<tr class="separator:ga24f292f35f2f61373ff4727e42786a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658ee4891ddc4170afcf48224a6417ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga658ee4891ddc4170afcf48224a6417ee">rtw_exit_critical_mutex</a> (_mutex *pmutex, _irqL *pirqL)</td></tr>
<tr class="memdesc:ga658ee4891ddc4170afcf48224a6417ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases a semaphore.  <a href="#ga658ee4891ddc4170afcf48224a6417ee">More...</a><br /></td></tr>
<tr class="separator:ga658ee4891ddc4170afcf48224a6417ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062ab4f0800f2fcc637fd7d05aff8a4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga062ab4f0800f2fcc637fd7d05aff8a4b">rtw_cpu_lock</a> (void)</td></tr>
<tr class="memdesc:ga062ab4f0800f2fcc637fd7d05aff8a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will lock cpu. Can be used when xip active and want to do some flash operation.  <a href="#ga062ab4f0800f2fcc637fd7d05aff8a4b">More...</a><br /></td></tr>
<tr class="separator:ga062ab4f0800f2fcc637fd7d05aff8a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ddc130bfad3a5271994ddc708c350ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga6ddc130bfad3a5271994ddc708c350ae">rtw_cpu_unlock</a> (void)</td></tr>
<tr class="memdesc:ga6ddc130bfad3a5271994ddc708c350ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unlock cpu.  <a href="#ga6ddc130bfad3a5271994ddc708c350ae">More...</a><br /></td></tr>
<tr class="separator:ga6ddc130bfad3a5271994ddc708c350ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37001b820c09b1a19cf192ded723010d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga37001b820c09b1a19cf192ded723010d">rtw_spinlock_init</a> (_lock *plock)</td></tr>
<tr class="memdesc:ga37001b820c09b1a19cf192ded723010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements a spin lock semaphore by using the existing queue mechanism.  <a href="#ga37001b820c09b1a19cf192ded723010d">More...</a><br /></td></tr>
<tr class="separator:ga37001b820c09b1a19cf192ded723010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef28ab6984d1cf7146af03b748c84454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaef28ab6984d1cf7146af03b748c84454">rtw_spinlock_free</a> (_lock *plock)</td></tr>
<tr class="memdesc:gaef28ab6984d1cf7146af03b748c84454"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes the spin lock semaphore.  <a href="#gaef28ab6984d1cf7146af03b748c84454">More...</a><br /></td></tr>
<tr class="separator:gaef28ab6984d1cf7146af03b748c84454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f01ed4e9126a09d40b702fe3d4525c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gad4f01ed4e9126a09d40b702fe3d4525c">rtw_spin_lock</a> (_lock *plock)</td></tr>
<tr class="memdesc:gad4f01ed4e9126a09d40b702fe3d4525c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains a spin lock semaphore.  <a href="#gad4f01ed4e9126a09d40b702fe3d4525c">More...</a><br /></td></tr>
<tr class="separator:gad4f01ed4e9126a09d40b702fe3d4525c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7267f308d095c538c0d897eaf63035e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gad7267f308d095c538c0d897eaf63035e">rtw_spin_unlock</a> (_lock *plock)</td></tr>
<tr class="memdesc:gad7267f308d095c538c0d897eaf63035e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases a spin lock semaphore.  <a href="#gad7267f308d095c538c0d897eaf63035e">More...</a><br /></td></tr>
<tr class="separator:gad7267f308d095c538c0d897eaf63035e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ad8236244e673850643924ce5078de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gac6ad8236244e673850643924ce5078de">rtw_spinlock_irqsave</a> (_lock *plock, _irqL *irqL)</td></tr>
<tr class="memdesc:gac6ad8236244e673850643924ce5078de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function marks the start of a critical code region and obtains a spin lock semaphore.  <a href="#gac6ad8236244e673850643924ce5078de">More...</a><br /></td></tr>
<tr class="separator:gac6ad8236244e673850643924ce5078de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac87035e791ade7f016b995a6de36b113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gac87035e791ade7f016b995a6de36b113">rtw_spinunlock_irqsave</a> (_lock *plock, _irqL *irqL)</td></tr>
<tr class="memdesc:gac87035e791ade7f016b995a6de36b113"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases a spin lock semaphore and marks the end of a critical code region.  <a href="#gac87035e791ade7f016b995a6de36b113">More...</a><br /></td></tr>
<tr class="separator:gac87035e791ade7f016b995a6de36b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac436de1bb8861d23654d3a7791cb15da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gac436de1bb8861d23654d3a7791cb15da">rtw_init_xqueue</a> (_xqueue *queue, const char *name, u32 message_size, u32 number_of_messages)</td></tr>
<tr class="memdesc:gac436de1bb8861d23654d3a7791cb15da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new queue instance.  <a href="#gac436de1bb8861d23654d3a7791cb15da">More...</a><br /></td></tr>
<tr class="separator:gac436de1bb8861d23654d3a7791cb15da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441c8d4a290d6686a80bebb8e41c59f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga441c8d4a290d6686a80bebb8e41c59f1">rtw_push_to_xqueue</a> (_xqueue *queue, void *message, u32 timeout_ms)</td></tr>
<tr class="memdesc:ga441c8d4a290d6686a80bebb8e41c59f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function posts a message to the back of a queue. The message is queued by copy, not by reference.  <a href="#ga441c8d4a290d6686a80bebb8e41c59f1">More...</a><br /></td></tr>
<tr class="separator:ga441c8d4a290d6686a80bebb8e41c59f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455fb88ce04abec31355991e71d32274"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga455fb88ce04abec31355991e71d32274">rtw_pop_from_xqueue</a> (_xqueue *queue, void *message, u32 timeout_ms)</td></tr>
<tr class="memdesc:ga455fb88ce04abec31355991e71d32274"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function receives a message from a queue. The message is recieved by copy so a buffer adequate size must be provided.  <a href="#ga455fb88ce04abec31355991e71d32274">More...</a><br /></td></tr>
<tr class="separator:ga455fb88ce04abec31355991e71d32274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64fd7ef8908a2640802c672327d4d46f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga64fd7ef8908a2640802c672327d4d46f">rtw_deinit_xqueue</a> (_xqueue *queue)</td></tr>
<tr class="memdesc:ga64fd7ef8908a2640802c672327d4d46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a queue - freeing all the memory allocated for storing of messages placed on the queue.  <a href="#ga64fd7ef8908a2640802c672327d4d46f">More...</a><br /></td></tr>
<tr class="separator:ga64fd7ef8908a2640802c672327d4d46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37abdd1a993f77351644abed9c5468c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga37abdd1a993f77351644abed9c5468c4">rtw_init_queue</a> (_queue *pqueue)</td></tr>
<tr class="memdesc:ga37abdd1a993f77351644abed9c5468c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new queue instance.  <a href="#ga37abdd1a993f77351644abed9c5468c4">More...</a><br /></td></tr>
<tr class="separator:ga37abdd1a993f77351644abed9c5468c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e9d6fa920cee8cfd10c4d7848a5206"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga09e9d6fa920cee8cfd10c4d7848a5206">rtw_queue_empty</a> (_queue *pqueue)</td></tr>
<tr class="memdesc:ga09e9d6fa920cee8cfd10c4d7848a5206"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether the queue is empty.  <a href="#ga09e9d6fa920cee8cfd10c4d7848a5206">More...</a><br /></td></tr>
<tr class="separator:ga09e9d6fa920cee8cfd10c4d7848a5206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e31ec8ce94b8c465ffb686047b47c14"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga9e31ec8ce94b8c465ffb686047b47c14">rtw_end_of_queue_search</a> (_list *queue, _list *pelement)</td></tr>
<tr class="memdesc:ga9e31ec8ce94b8c465ffb686047b47c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether the "pelement" is at the "queue".  <a href="#ga9e31ec8ce94b8c465ffb686047b47c14">More...</a><br /></td></tr>
<tr class="separator:ga9e31ec8ce94b8c465ffb686047b47c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga388ad68fb55be66baa224afcf504dddd"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga388ad68fb55be66baa224afcf504dddd">rtw_get_current_time</a> (void)</td></tr>
<tr class="memdesc:ga388ad68fb55be66baa224afcf504dddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count of ticks since the vTaskStartScheduler was called.  <a href="#ga388ad68fb55be66baa224afcf504dddd">More...</a><br /></td></tr>
<tr class="separator:ga388ad68fb55be66baa224afcf504dddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8674586494dd8574362f90ffa8401a54"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga8674586494dd8574362f90ffa8401a54">rtw_systime_to_ms</a> (u32 systime)</td></tr>
<tr class="memdesc:ga8674586494dd8574362f90ffa8401a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert system time to milliseconds.  <a href="#ga8674586494dd8574362f90ffa8401a54">More...</a><br /></td></tr>
<tr class="separator:ga8674586494dd8574362f90ffa8401a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d180388ea1f302c61467595c44e6ab5"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga6d180388ea1f302c61467595c44e6ab5">rtw_systime_to_sec</a> (u32 systime)</td></tr>
<tr class="memdesc:ga6d180388ea1f302c61467595c44e6ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert system time to seconds.  <a href="#ga6d180388ea1f302c61467595c44e6ab5">More...</a><br /></td></tr>
<tr class="separator:ga6d180388ea1f302c61467595c44e6ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cc21a9fcd329ae2a3e7f399d230176"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gad3cc21a9fcd329ae2a3e7f399d230176">rtw_ms_to_systime</a> (u32 ms)</td></tr>
<tr class="memdesc:gad3cc21a9fcd329ae2a3e7f399d230176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert milliseconds to system time.  <a href="#gad3cc21a9fcd329ae2a3e7f399d230176">More...</a><br /></td></tr>
<tr class="separator:gad3cc21a9fcd329ae2a3e7f399d230176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5babf897e2d8284329aeae10c88520"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga6a5babf897e2d8284329aeae10c88520">rtw_sec_to_systime</a> (u32 sec)</td></tr>
<tr class="memdesc:ga6a5babf897e2d8284329aeae10c88520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert seconds to system time.  <a href="#ga6a5babf897e2d8284329aeae10c88520">More...</a><br /></td></tr>
<tr class="separator:ga6a5babf897e2d8284329aeae10c88520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29555dec53b9cfd459ca0c7b3a0afa8"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gab29555dec53b9cfd459ca0c7b3a0afa8">rtw_get_passing_time_ms</a> (u32 start)</td></tr>
<tr class="memdesc:gab29555dec53b9cfd459ca0c7b3a0afa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the passing time from the "start" in milliseconds.  <a href="#gab29555dec53b9cfd459ca0c7b3a0afa8">More...</a><br /></td></tr>
<tr class="separator:gab29555dec53b9cfd459ca0c7b3a0afa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bc34bd42ed88ca127f481165bdb9b63"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga8bc34bd42ed88ca127f481165bdb9b63">rtw_get_time_interval_ms</a> (u32 start, u32 end)</td></tr>
<tr class="memdesc:ga8bc34bd42ed88ca127f481165bdb9b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interval time from the "start" to "end" in milliseconds.  <a href="#ga8bc34bd42ed88ca127f481165bdb9b63">More...</a><br /></td></tr>
<tr class="separator:ga8bc34bd42ed88ca127f481165bdb9b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46a8d1780b6f053d1ac91e1609a23be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gab46a8d1780b6f053d1ac91e1609a23be">rtw_msleep_os</a> (int ms)</td></tr>
<tr class="memdesc:gab46a8d1780b6f053d1ac91e1609a23be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function suspends execution of the calling thread for "ms" milliseconds.  <a href="#gab46a8d1780b6f053d1ac91e1609a23be">More...</a><br /></td></tr>
<tr class="separator:gab46a8d1780b6f053d1ac91e1609a23be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32743271ed298e09a4a5d6d55ab8736e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga32743271ed298e09a4a5d6d55ab8736e">rtw_usleep_os</a> (int us)</td></tr>
<tr class="memdesc:ga32743271ed298e09a4a5d6d55ab8736e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function suspends execution of the calling thread for "us" microseconds.  <a href="#ga32743271ed298e09a4a5d6d55ab8736e">More...</a><br /></td></tr>
<tr class="separator:ga32743271ed298e09a4a5d6d55ab8736e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5382ca9167916b15af0880f5efe838"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaaf5382ca9167916b15af0880f5efe838">rtw_atoi</a> (u8 *s)</td></tr>
<tr class="memdesc:gaaf5382ca9167916b15af0880f5efe838"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the initial portion of the string to integer.  <a href="#gaaf5382ca9167916b15af0880f5efe838">More...</a><br /></td></tr>
<tr class="separator:gaaf5382ca9167916b15af0880f5efe838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f2c25e0e8525260b0283938acf3e5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gad8f2c25e0e8525260b0283938acf3e5f">rtw_mdelay_os</a> (int ms)</td></tr>
<tr class="memdesc:gad8f2c25e0e8525260b0283938acf3e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function delays a task for the giving time in milliseconds.  <a href="#gad8f2c25e0e8525260b0283938acf3e5f">More...</a><br /></td></tr>
<tr class="separator:gad8f2c25e0e8525260b0283938acf3e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2a43ba4d719a9577d717e7f047a44eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaf2a43ba4d719a9577d717e7f047a44eb">rtw_udelay_os</a> (int us)</td></tr>
<tr class="memdesc:gaf2a43ba4d719a9577d717e7f047a44eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function delays a task for the giving time in microseconds.  <a href="#gaf2a43ba4d719a9577d717e7f047a44eb">More...</a><br /></td></tr>
<tr class="separator:gaf2a43ba4d719a9577d717e7f047a44eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1d04350f2daf1172a7c4baf27f023e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gad1d04350f2daf1172a7c4baf27f023e4">rtw_yield_os</a> (void)</td></tr>
<tr class="memdesc:gad1d04350f2daf1172a7c4baf27f023e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function for forcing a context switch.  <a href="#gad1d04350f2daf1172a7c4baf27f023e4">More...</a><br /></td></tr>
<tr class="separator:gad1d04350f2daf1172a7c4baf27f023e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773eff3884ab09b0b2adfae502c6fbb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga773eff3884ab09b0b2adfae502c6fbb3">ATOMIC_SET</a> (ATOMIC_T *v, int i)</td></tr>
<tr class="memdesc:ga773eff3884ab09b0b2adfae502c6fbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function atomically sets the value of the variable.  <a href="#ga773eff3884ab09b0b2adfae502c6fbb3">More...</a><br /></td></tr>
<tr class="separator:ga773eff3884ab09b0b2adfae502c6fbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3db066675908db9b865ce38db5abc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaea3db066675908db9b865ce38db5abc1">ATOMIC_READ</a> (ATOMIC_T *v)</td></tr>
<tr class="memdesc:gaea3db066675908db9b865ce38db5abc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function atomically reads the value of the variable.  <a href="#gaea3db066675908db9b865ce38db5abc1">More...</a><br /></td></tr>
<tr class="separator:gaea3db066675908db9b865ce38db5abc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40eb2eab2fe72770b747959a37c9dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gae40eb2eab2fe72770b747959a37c9dfa">ATOMIC_ADD</a> (ATOMIC_T *v, int i)</td></tr>
<tr class="memdesc:gae40eb2eab2fe72770b747959a37c9dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds "i" to the contained "v".  <a href="#gae40eb2eab2fe72770b747959a37c9dfa">More...</a><br /></td></tr>
<tr class="separator:gae40eb2eab2fe72770b747959a37c9dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc182a9a76b9ab086fb850ef4a3fa9d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gadc182a9a76b9ab086fb850ef4a3fa9d4">ATOMIC_SUB</a> (ATOMIC_T *v, int i)</td></tr>
<tr class="memdesc:gadc182a9a76b9ab086fb850ef4a3fa9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function subtracts "i" from th econtained "v".  <a href="#gadc182a9a76b9ab086fb850ef4a3fa9d4">More...</a><br /></td></tr>
<tr class="separator:gadc182a9a76b9ab086fb850ef4a3fa9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37d5eb980755600e00f7870dddfc9201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga37d5eb980755600e00f7870dddfc9201">ATOMIC_INC</a> (ATOMIC_T *v)</td></tr>
<tr class="memdesc:ga37d5eb980755600e00f7870dddfc9201"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds 1 to the contained "v".  <a href="#ga37d5eb980755600e00f7870dddfc9201">More...</a><br /></td></tr>
<tr class="separator:ga37d5eb980755600e00f7870dddfc9201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed19ec7dd00eb7f86e731973e503d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga6ed19ec7dd00eb7f86e731973e503d38">ATOMIC_DEC</a> (ATOMIC_T *v)</td></tr>
<tr class="memdesc:ga6ed19ec7dd00eb7f86e731973e503d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function subtracts 1 from th econtained "v".  <a href="#ga6ed19ec7dd00eb7f86e731973e503d38">More...</a><br /></td></tr>
<tr class="separator:ga6ed19ec7dd00eb7f86e731973e503d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafe4466dbf996db5b4f65b2154184374"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaafe4466dbf996db5b4f65b2154184374">ATOMIC_ADD_RETURN</a> (ATOMIC_T *v, int i)</td></tr>
<tr class="memdesc:gaafe4466dbf996db5b4f65b2154184374"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds "i" to the contained "v" and returns the result.  <a href="#gaafe4466dbf996db5b4f65b2154184374">More...</a><br /></td></tr>
<tr class="separator:gaafe4466dbf996db5b4f65b2154184374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a0f53c84834521a0794d3c317fcdd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gab2a0f53c84834521a0794d3c317fcdd7">ATOMIC_SUB_RETURN</a> (ATOMIC_T *v, int i)</td></tr>
<tr class="memdesc:gab2a0f53c84834521a0794d3c317fcdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function subtracts "i" from th econtained "v" and returns the result.  <a href="#gab2a0f53c84834521a0794d3c317fcdd7">More...</a><br /></td></tr>
<tr class="separator:gab2a0f53c84834521a0794d3c317fcdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec0db9ec483df31ae5543c47c9ddaa5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga8ec0db9ec483df31ae5543c47c9ddaa5">ATOMIC_INC_RETURN</a> (ATOMIC_T *v)</td></tr>
<tr class="memdesc:ga8ec0db9ec483df31ae5543c47c9ddaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds 1 to the contained "v" and returns the result.  <a href="#ga8ec0db9ec483df31ae5543c47c9ddaa5">More...</a><br /></td></tr>
<tr class="separator:ga8ec0db9ec483df31ae5543c47c9ddaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9fc2abd337dff5eb39d0dcaf245096c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gad9fc2abd337dff5eb39d0dcaf245096c">ATOMIC_DEC_RETURN</a> (ATOMIC_T *v)</td></tr>
<tr class="memdesc:gad9fc2abd337dff5eb39d0dcaf245096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function subtracts 1 from th econtained "v" and returns the result.  <a href="#gad9fc2abd337dff5eb39d0dcaf245096c">More...</a><br /></td></tr>
<tr class="separator:gad9fc2abd337dff5eb39d0dcaf245096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fec214a366463f97068abc3d5bfb687"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga9fec214a366463f97068abc3d5bfb687">ATOMIC_DEC_AND_TEST</a> (ATOMIC_T *v)</td></tr>
<tr class="memdesc:ga9fec214a366463f97068abc3d5bfb687"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function subtracts 1 from th econtained "v" and test if the result equals 0.  <a href="#ga9fec214a366463f97068abc3d5bfb687">More...</a><br /></td></tr>
<tr class="separator:ga9fec214a366463f97068abc3d5bfb687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga544cb429c5677ce1d0bd5f354c2b7673"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga544cb429c5677ce1d0bd5f354c2b7673">rtw_get_random_bytes</a> (void *dst, u32 size)</td></tr>
<tr class="memdesc:ga544cb429c5677ce1d0bd5f354c2b7673"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates random bytes.  <a href="#ga544cb429c5677ce1d0bd5f354c2b7673">More...</a><br /></td></tr>
<tr class="separator:ga544cb429c5677ce1d0bd5f354c2b7673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe16158e1e19265e765c0b85399919d"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gacfe16158e1e19265e765c0b85399919d">rtw_getFreeHeapSize</a> (void)</td></tr>
<tr class="memdesc:gacfe16158e1e19265e765c0b85399919d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the available heap size.  <a href="#gacfe16158e1e19265e765c0b85399919d">More...</a><br /></td></tr>
<tr class="separator:gacfe16158e1e19265e765c0b85399919d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf87f11f7a0f0b78efc5fd5156bfa83c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gacf87f11f7a0f0b78efc5fd5156bfa83c">rtw_acquire_wakelock</a> (void)</td></tr>
<tr class="memdesc:gacf87f11f7a0f0b78efc5fd5156bfa83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function indicates that the WLAN needs to stay on which means cannot go into power saving mode.  <a href="#gacf87f11f7a0f0b78efc5fd5156bfa83c">More...</a><br /></td></tr>
<tr class="separator:gacf87f11f7a0f0b78efc5fd5156bfa83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1471dbb012522a892cc24edb3d93ba21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga1471dbb012522a892cc24edb3d93ba21">rtw_release_wakelock</a> (void)</td></tr>
<tr class="memdesc:ga1471dbb012522a892cc24edb3d93ba21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function indicates that the WLAN does not need to stay on which means can go into power saving mode.  <a href="#ga1471dbb012522a892cc24edb3d93ba21">More...</a><br /></td></tr>
<tr class="separator:ga1471dbb012522a892cc24edb3d93ba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa51afb2660acc623a9b423e6f8d5f7ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gaa51afb2660acc623a9b423e6f8d5f7ec">rtw_create_task</a> (struct <a class="el" href="structtask__struct.html">task_struct</a> *task, const char *name, u32 stack_size, u32 priority, thread_func_t func, void *thctx)</td></tr>
<tr class="memdesc:gaa51afb2660acc623a9b423e6f8d5f7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new task and adds it to the list of tasks that are ready to run.  <a href="#gaa51afb2660acc623a9b423e6f8d5f7ec">More...</a><br /></td></tr>
<tr class="separator:gaa51afb2660acc623a9b423e6f8d5f7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2c40877bebfdd7c08484792e7a0bc24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gad2c40877bebfdd7c08484792e7a0bc24">rtw_delete_task</a> (struct <a class="el" href="structtask__struct.html">task_struct</a> *task)</td></tr>
<tr class="memdesc:gad2c40877bebfdd7c08484792e7a0bc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes a task.  <a href="#gad2c40877bebfdd7c08484792e7a0bc24">More...</a><br /></td></tr>
<tr class="separator:gad2c40877bebfdd7c08484792e7a0bc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d259d21a6ce29d0805e8f36f4ddfcc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga9d259d21a6ce29d0805e8f36f4ddfcc4">rtw_wakeup_task</a> (struct <a class="el" href="structtask__struct.html">task_struct</a> *task)</td></tr>
<tr class="memdesc:ga9d259d21a6ce29d0805e8f36f4ddfcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function wake up a task.  <a href="#ga9d259d21a6ce29d0805e8f36f4ddfcc4">More...</a><br /></td></tr>
<tr class="separator:ga9d259d21a6ce29d0805e8f36f4ddfcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9c7c644b1163085e9f196d8a543b7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gabb9c7c644b1163085e9f196d8a543b7d">rtw_create_worker_thread</a> (<a class="el" href="structrtw__worker__thread__t.html">rtw_worker_thread_t</a> *worker_thread, u8 priority, u32 stack_size, u32 event_queue_size)</td></tr>
<tr class="memdesc:gabb9c7c644b1163085e9f196d8a543b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new worker thread.  <a href="#gabb9c7c644b1163085e9f196d8a543b7d">More...</a><br /></td></tr>
<tr class="separator:gabb9c7c644b1163085e9f196d8a543b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d7555282b121476074275d0a3b3eb70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga3d7555282b121476074275d0a3b3eb70">rtw_delete_worker_thread</a> (<a class="el" href="structrtw__worker__thread__t.html">rtw_worker_thread_t</a> *worker_thread)</td></tr>
<tr class="memdesc:ga3d7555282b121476074275d0a3b3eb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes a worker thread.  <a href="#ga3d7555282b121476074275d0a3b3eb70">More...</a><br /></td></tr>
<tr class="separator:ga3d7555282b121476074275d0a3b3eb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f70a3abe91f6e1958eabce586f3b704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga4f70a3abe91f6e1958eabce586f3b704">rtw_thread_enter</a> (char *name)</td></tr>
<tr class="memdesc:ga4f70a3abe91f6e1958eabce586f3b704"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the name of the thread in DBG_INFO.  <a href="#ga4f70a3abe91f6e1958eabce586f3b704">More...</a><br /></td></tr>
<tr class="separator:ga4f70a3abe91f6e1958eabce586f3b704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86052516c9cb6c3a4c1bc90e1cca303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gac86052516c9cb6c3a4c1bc90e1cca303">rtw_thread_exit</a> (void)</td></tr>
<tr class="memdesc:gac86052516c9cb6c3a4c1bc90e1cca303"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exits the calling thread.  <a href="#gac86052516c9cb6c3a4c1bc90e1cca303">More...</a><br /></td></tr>
<tr class="separator:gac86052516c9cb6c3a4c1bc90e1cca303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a2aff5d28a079185ae68f78ff1ce7f"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga15a2aff5d28a079185ae68f78ff1ce7f">rtw_get_scheduler_state</a> (void)</td></tr>
<tr class="memdesc:ga15a2aff5d28a079185ae68f78ff1ce7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the scheduler state of the calling thread.  <a href="#ga15a2aff5d28a079185ae68f78ff1ce7f">More...</a><br /></td></tr>
<tr class="separator:ga15a2aff5d28a079185ae68f78ff1ce7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ccbab114f0894d52f6b6c03f4167d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gae0ccbab114f0894d52f6b6c03f4167d9">rtw_create_secure_context</a> (u32 secure_stack_size)</td></tr>
<tr class="memdesc:gae0ccbab114f0894d52f6b6c03f4167d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creats secure stack for threads.  <a href="#gae0ccbab114f0894d52f6b6c03f4167d9">More...</a><br /></td></tr>
<tr class="separator:gae0ccbab114f0894d52f6b6c03f4167d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac584192034fe149a89a9c6ff816cb824"><td class="memItemLeft" align="right" valign="top">_timerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gac584192034fe149a89a9c6ff816cb824">rtw_timerCreate</a> (const signed char *pcTimerName, osdepTickType xTimerPeriodInTicks, u32 uxAutoReload, void *pvTimerID, TIMER_FUN pxCallbackFunction)</td></tr>
<tr class="memdesc:gac584192034fe149a89a9c6ff816cb824"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new software timer instance.  <a href="#gac584192034fe149a89a9c6ff816cb824">More...</a><br /></td></tr>
<tr class="separator:gac584192034fe149a89a9c6ff816cb824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c7ca6935ebab8b73083de9893afd09"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga70c7ca6935ebab8b73083de9893afd09">rtw_timerDelete</a> (_timerHandle xTimer, osdepTickType xBlockTime)</td></tr>
<tr class="memdesc:ga70c7ca6935ebab8b73083de9893afd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes a timer that was previously created using rtw_timerCreate.  <a href="#ga70c7ca6935ebab8b73083de9893afd09">More...</a><br /></td></tr>
<tr class="separator:ga70c7ca6935ebab8b73083de9893afd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a7497759cd3304af7e1ea19fe9d3627"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga2a7497759cd3304af7e1ea19fe9d3627">rtw_timerIsTimerActive</a> (_timerHandle xTimer)</td></tr>
<tr class="memdesc:ga2a7497759cd3304af7e1ea19fe9d3627"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function queries a timer to see if it is active or dormant.  <a href="#ga2a7497759cd3304af7e1ea19fe9d3627">More...</a><br /></td></tr>
<tr class="separator:ga2a7497759cd3304af7e1ea19fe9d3627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658aea6db26460a6d9d9b3c4d1f46d21"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#ga658aea6db26460a6d9d9b3c4d1f46d21">rtw_timerStop</a> (_timerHandle xTimer, osdepTickType xBlockTime)</td></tr>
<tr class="memdesc:ga658aea6db26460a6d9d9b3c4d1f46d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops a timer that was previously started.  <a href="#ga658aea6db26460a6d9d9b3c4d1f46d21">More...</a><br /></td></tr>
<tr class="separator:ga658aea6db26460a6d9d9b3c4d1f46d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbc6483e7d29c8ab1918784d20724ff6"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_o_s.html#gabbc6483e7d29c8ab1918784d20724ff6">rtw_timerChangePeriod</a> (_timerHandle xTimer, osdepTickType xNewPeriod, osdepTickType xBlockTime)</td></tr>
<tr class="memdesc:gabbc6483e7d29c8ab1918784d20724ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function changes the period of a timer that was previously created.  <a href="#gabbc6483e7d29c8ab1918784d20724ff6">More...</a><br /></td></tr>
<tr class="separator:gabbc6483e7d29c8ab1918784d20724ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>RTOS functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa8fba4d853a4b5981aaaa0e37cdae7de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_mem_usage </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>pmem_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>used_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function alloc <a class="el" href="structmem__entry.html">mem_entry</a> to the memory table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmem_table</td><td>The pointer to the memory table to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer to the position to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of added memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">used_num</td><td>The number of <a class="el" href="structmem__entry.html">mem_entry</a> kept in monitor which will add 1 after. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>MEM_MONITOR_FLAG_WPAS/MEM_MONITOR_FLAG_WIFI_DRV </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gae40eb2eab2fe72770b747959a37c9dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATOMIC_ADD </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds "i" to the contained "v". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaafe4466dbf996db5b4f65b2154184374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ATOMIC_ADD_RETURN </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds "i" to the contained "v" and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ed19ec7dd00eb7f86e731973e503d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATOMIC_DEC </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function subtracts 1 from th econtained "v". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fec214a366463f97068abc3d5bfb687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ATOMIC_DEC_AND_TEST </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function subtracts 1 from th econtained "v" and test if the result equals 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: The result after subtracting 1 is 0 </dd>
<dd>
-1: The result after subtracting 1 is not 0 </dd></dl>

</div>
</div>
<a class="anchor" id="gad9fc2abd337dff5eb39d0dcaf245096c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ATOMIC_DEC_RETURN </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function subtracts 1 from th econtained "v" and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga37d5eb980755600e00f7870dddfc9201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATOMIC_INC </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds 1 to the contained "v". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ec0db9ec483df31ae5543c47c9ddaa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ATOMIC_INC_RETURN </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds 1 to the contained "v" and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaea3db066675908db9b865ce38db5abc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ATOMIC_READ </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function atomically reads the value of the variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t that to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the variable. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The guaranteed useful range of an atomic_t is only 24 bits. </dd></dl>

</div>
</div>
<a class="anchor" id="ga773eff3884ab09b0b2adfae502c6fbb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATOMIC_SET </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function atomically sets the value of the variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t that to be set value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Required value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The guaranteed useful range of an atomic_t is only 24 bits. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc182a9a76b9ab086fb850ef4a3fa9d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATOMIC_SUB </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function subtracts "i" from th econtained "v". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>value to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gab2a0f53c84834521a0794d3c317fcdd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ATOMIC_SUB_RETURN </td>
          <td>(</td>
          <td class="paramtype">ATOMIC_T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function subtracts "i" from th econtained "v" and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer of type atomic_t. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>value to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga37363e084632199f1870b3105a7dc454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deinit_mem_monitor </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>pmem_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>used_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deinitializes a memory table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmem_table</td><td>The pointer to the memory table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">used_num</td><td>The number of <a class="el" href="structmem__entry.html">mem_entry</a> kept in monitor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gadf74d3a405d503e2465988dffa6f1a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void del_mem_usage </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>pmem_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>used_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees memory from the memory table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmem_table</td><td>The pointer to the memory table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer to the position to be free. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">used_num</td><td>The number of <a class="el" href="structmem__entry.html">mem_entry</a> kept in monitor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>MEM_MONITOR_FLAG_WPAS/MEM_MONITOR_FLAG_WIFI_DRV </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa56f111283bb33a374b7d4d0bc1c94c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_mem_usage </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>pmem_table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function get the memory usage of a memory table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmem_table</td><td>The pointer to the memory table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the memory used </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f8235595e6f9b556f30025bcc149f21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_mem_monitor </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>pmem_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>used_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes a memory table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmem_table</td><td>The pointer to the memory table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">used_num</td><td>The number of <a class="el" href="structmem__entry.html">mem_entry</a> kept in monitor which will be set to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gacf87f11f7a0f0b78efc5fd5156bfa83c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_acquire_wakelock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function indicates that the WLAN needs to stay on which means cannot go into power saving mode. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defining configUSE_WAKELOCK_PMU 1 in "FreeRTOSConfig.h" needs to be done before compiling, or this API won't be effective. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf5382ca9167916b15af0880f5efe838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_atoi </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the initial portion of the string to integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The pointer to the string to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga062ab4f0800f2fcc637fd7d05aff8a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_cpu_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will lock cpu. Can be used when xip active and want to do some flash operation. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ddc130bfad3a5271994ddc708c350ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_cpu_unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unlock cpu. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gae0ccbab114f0894d52f6b6c03f4167d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_create_secure_context </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>secure_stack_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creats secure stack for threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">secure_stack_size</td><td>The size of the secure stack for this thread, the unit is byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa51afb2660acc623a9b423e6f8d5f7ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_create_task </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_func_t&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>thctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a new task and adds it to the list of tasks that are ready to run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task stucture which will store the task related infomation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A descriptive name for the task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_size</td><td>The size of the task stack specified as the variables the stack can hold. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>The priority at which the task should run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The task entry function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thctx</td><td>The pointer that will be used as the parameter for the task being created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdPASS: The task was successfully created and added to a ready list. </dd>
<dd>
other error code defined in the file errors.h. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For the task name, please do not use "rtw_little_wifi_mcu_thread", "rtw_check_in_req_state_thread", "rtw_TDMA_change_state_thread", "xmit_thread", "recv_thread", "rtw_recv_tasklet", "rtw_xmit_tasklet", "rtw_interrupt_thread", "cmd_thread", "usb_init", "MSC_BULK_CMD" and "MSC_BULK_DATA". </dd></dl>

</div>
</div>
<a class="anchor" id="gabb9c7c644b1163085e9f196d8a543b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_create_worker_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtw__worker__thread__t.html">rtw_worker_thread_t</a> *&#160;</td>
          <td class="paramname"><em>worker_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>event_queue_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a new worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker_thread</td><td>The pointer to the worker thread stucture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>The priority of the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_size</td><td>The size of the thread stack specified as the variables the stack can hold. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event_queue_size</td><td>The queue size of events. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SUCCESS/FAIL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64fd7ef8908a2640802c672327d4d46f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_deinit_xqueue </td>
          <td>(</td>
          <td class="paramtype">_xqueue *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a queue - freeing all the memory allocated for storing of messages placed on the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The handle to the queue to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: The queue was successfully deleted. </dd>
<dd>
-1: The queue was not empty so cannot be deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="gad2c40877bebfdd7c08484792e7a0bc24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_delete_task </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task stucture which will be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d7555282b121476074275d0a3b3eb70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_delete_worker_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtw__worker__thread__t.html">rtw_worker_thread_t</a> *&#160;</td>
          <td class="paramname"><em>worker_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes a worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker_thread</td><td>The pointer to the worker thread stucture to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SUCCESS/FAIL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8866f237041311efe4a0096a901c82c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_down_sema </td>
          <td>(</td>
          <td class="paramtype">_sema *&#160;</td>
          <td class="paramname"><em>sema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function acquires the semaphore. If no more tasks are allowed to acquire the semaphore, calling this function will put the task to sleep until the semaphore is up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sema</td><td>The semaphore to be acquired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE: The semaphore was obtained. </dd>
<dd>
pdFALSE: Obtain the semaphore failed. </dd></dl>

</div>
</div>
<a class="anchor" id="gaef950465b7b07566a08e6ae45803de5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_down_timeout_sema </td>
          <td>(</td>
          <td class="paramtype">_sema *&#160;</td>
          <td class="paramname"><em>sema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function acquires the semaphore. If no more tasks are allowed to acquire the semaphore, calling this function will put the task to sleep until the semaphore is up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sema</td><td>The semaphore to be acquired. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The time in ms to wait for the semaphore to become available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE: The semaphore was obtained. </dd>
<dd>
pdFALSE: Timeout without the semaphore becoming available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e31ec8ce94b8c465ffb686047b47c14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_end_of_queue_search </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>pelement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether the "pelement" is at the "queue". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The pointer to the queue that to be tested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pelement</td><td>The element that to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>_TRUE/_FALSE </dd></dl>

</div>
</div>
<a class="anchor" id="ga25ebf88345d437f95ac6db2534a9f3bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_enter_critical </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>pirqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function marks the start of a critical code region. Preemptive context switches cannot occur when in a critical region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pirqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This may alter the stack (depending on the portable implementation) so must be used with care! </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c65ec3e920cf2096815d65cb73c417c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_enter_critical_bh </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>pirqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains a spin lock semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore being taken - obtained when the mutex semaphore was created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pirqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gad8b05366edfa20347cbd6501b9e77ec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_enter_critical_from_isr </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>pirqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function marks the start of a critical code region from isr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pirqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga24f292f35f2f61373ff4727e42786a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_enter_critical_mutex </td>
          <td>(</td>
          <td class="paramtype">_mutex *&#160;</td>
          <td class="paramname"><em>pmutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>pirqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>The handle to the mutex semaphore to be obtained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pirqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gab0a8793d6348a9b8875163fd04961b38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_exit_critical </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>pirqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function marks end of a critical code region. Preemptive context switches cannot occur when in a critical region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pirqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This may alter the stack (depending on the portable implementation) so must be used with care! </dd></dl>

</div>
</div>
<a class="anchor" id="ga098121bd2ccffdb029660cab44ebeede"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_exit_critical_bh </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>pirqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases a spin lock semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore to be released. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pirqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga58e735aa05f4c73300225a4b9ccb2bfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_exit_critical_from_isr </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>pirqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function marks the end of a critical code region from isr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pirqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga658ee4891ddc4170afcf48224a6417ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_exit_critical_mutex </td>
          <td>(</td>
          <td class="paramtype">_mutex *&#160;</td>
          <td class="paramname"><em>pmutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>pirqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>The handle to the mutex semaphore to be released. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pirqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gae38a2d622f9867e03a61245badd4a481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_free_sema </td>
          <td>(</td>
          <td class="paramtype">_sema *&#160;</td>
          <td class="paramname"><em>sema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes the semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sema</td><td>The semaphore to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga388ad68fb55be66baa224afcf504dddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_get_current_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the count of ticks since the vTaskStartScheduler was called. </p>
<dl class="section return"><dt>Returns</dt><dd>The count of ticks since the vTaskStartScheduler was called. </dd></dl>

</div>
</div>
<a class="anchor" id="gab29555dec53b9cfd459ca0c7b3a0afa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 rtw_get_passing_time_ms </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the passing time from the "start" in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start time which is in system time format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: The passing time from "start" in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="ga544cb429c5677ce1d0bd5f354c2b7673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_get_random_bytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates random bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>The pointer to the buffer to store the random bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the random bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga15a2aff5d28a079185ae68f78ff1ce7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 rtw_get_scheduler_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the scheduler state of the calling thread. </p>
<dl class="section return"><dt>Returns</dt><dd>OS_SCHEDULER_NOT_STARTED </dd>
<dd>
OS_SCHEDULER_RUNNING </dd>
<dd>
OS_SCHEDULER_SUSPENDED </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bc34bd42ed88ca127f481165bdb9b63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 rtw_get_time_interval_ms </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interval time from the "start" to "end" in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start time which is in system time format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end time which is in system time format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: The interval time from "start" to "end" in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="gacfe16158e1e19265e765c0b85399919d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_getFreeHeapSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the available heap size. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the available heap size. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e3c7baf89d8fd411e5ed5dc9682c2ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_init_listhead </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the head of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>Pointer to the list to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga37abdd1a993f77351644abed9c5468c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_init_queue </td>
          <td>(</td>
          <td class="paramtype">_queue *&#160;</td>
          <td class="paramname"><em>pqueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a new queue instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>The handle to the newly created queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga672f0efc2e47205a5379fe474e7a176b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_init_sema </td>
          <td>(</td>
          <td class="paramtype">_sema *&#160;</td>
          <td class="paramname"><em>sema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>init_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the unnamed semaphore referred to by "sema" to the value "init_val". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sema</td><td>Pointer to the semaphore handle to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_val</td><td>Initial value for semaphore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac436de1bb8861d23654d3a7791cb15da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_init_xqueue </td>
          <td>(</td>
          <td class="paramtype">_xqueue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>message_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>number_of_messages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a new queue instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The handle to the newly created queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_size</td><td>The number of bytes each message in the queue will require. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_messages</td><td>The maximum number of messages that kthe queue can contain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: Creating queue success </dd>
<dd>
-1: Creating queue fail </dd></dl>

</div>
</div>
<a class="anchor" id="gabfab29b24ba6eac2f7daf8a37946eed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_is_list_empty </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>phead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether a list is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phead</td><td>Pointer to the list to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>_TRUE/_FALSE </dd></dl>

</div>
</div>
<a class="anchor" id="gad2f1bf966f380681638ec580b709ee77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_list_delete </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>plist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes entry from list and reinitialize it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plist</td><td>The element to delete from the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Caller must check if the list is empty before calling rtw_list_delete </dd></dl>

</div>
</div>
<a class="anchor" id="ga804faac1fb48202fb596096d27679fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_list_insert_head </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>phead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds a new entry after "phead" for the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plist</td><td>Pointer to the list to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phead</td><td>List head to add it after. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f342e747430bbf855b1b0f845bf9d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_list_insert_tail </td>
          <td>(</td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_list *&#160;</td>
          <td class="paramname"><em>phead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds a new entry before "phead" for the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plist</td><td>Pointer to the list to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phead</td><td>List head to add it before. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac38480df2657a06473435aebecf3f0f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* rtw_malloc </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates the memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The size of memory to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the beginning of the memory </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e5cfcf0bfa0cf4d12b3140c927474a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rtw_malloc2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates a 2 dimensional array memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The height of the 2D array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The width of the 2D array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the each charactor in array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the beginning of the block </dd></dl>

</div>
</div>
<a class="anchor" id="gad8f2c25e0e8525260b0283938acf3e5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_mdelay_os </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function delays a task for the giving time in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The amount of time, in milliseconds, that the calling task should block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa049f0f8d4f7f3dc1dccaa7cab8b00e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_memcmp </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares the first "sz" bytes of the block of memory pointed by "dst" to the first "sz" bytes pointed by "src". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Pointer to block of memory to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to block of memory to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of memory to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0: The first byte that does not match in both memory blocks has a lower value in dst than in src. </dd>
<dd>
0: The contents of both memory blocks are equal. </dd>
<dd>
&lt;0: The first byte that does not match in both memory blocks has a greater value in dst than in src. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b31fb541897d351bcf322467e7626ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies the values of "sz" bytes from the location pointed to by "src" directly to the memory block pointed to by "des". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Pointer to the destination array where the content is to be copied, type-casted to a pointer of type void*. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Pointer to the source of data to be copied, type-casted to a pointer of type void*. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of memory to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5db16ab98682918647b010a65daf179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the first "sz" bytes of the block of memory pointed by "pbuf" to the specified "c". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pbuf</td><td>Pointer to the block of memory to fill. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>Size of memory to be set to the value "c". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga210903829e249ee36ebbae895fdfeb68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_mfree </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>pbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees the virtually contiguous memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pbuf</td><td>The pointer to the beginning of the memory to be free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The size of memory allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b960a8744e7f4d12336cbcce554f10b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_mfree2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deallocates the block of memory previously allocated to make it available again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pbuf</td><td>Pointer to a memory block previously allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The height of the 2D array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The width of the 2D array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the each charactor in array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gad3cc21a9fcd329ae2a3e7f399d230176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_ms_to_systime </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert milliseconds to system time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systime</td><td>The milliseconds to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: The system time that converted by the milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="gab46a8d1780b6f053d1ac91e1609a23be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_msleep_os </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function suspends execution of the calling thread for "ms" milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The time that the function sleep in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a2f29a11830cdc9030a91f6ed49f74a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_mutex_free </td>
          <td>(</td>
          <td class="paramtype">_mutex *&#160;</td>
          <td class="paramname"><em>pmutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes the mutex semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>Pointer to the mutex semaphore to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga62acfe38de294d000720de79d20ea3e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_mutex_get </td>
          <td>(</td>
          <td class="paramtype">_mutex *&#160;</td>
          <td class="paramname"><em>pmutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains a mutex semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>Pointer to the mutex semaphore being taken - obtained when the mutex semaphore was created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga29651aa1be8c5cfaa8dcbecb5917bb3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_mutex_get_timeout </td>
          <td>(</td>
          <td class="paramtype">_mutex *&#160;</td>
          <td class="paramname"><em>pmutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains a mutex semaphore with a timeout setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>Pointer to the mutex semaphore being taken - obtained when the mutex semaphore was created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The time in ms to wait for the semaphore to become available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: The semaphore was obtained. </dd>
<dd>
-1: Timeout without the semaphore becoming available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46eb1c50c29acf8e4052707ab51e768c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_mutex_init </td>
          <td>(</td>
          <td class="paramtype">_mutex *&#160;</td>
          <td class="paramname"><em>pmutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements a mutex semaphore by using the existing queue mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>Pointer to the created mutex semaphore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga61df40838863df72ef65ad766aee3fa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_mutex_put </td>
          <td>(</td>
          <td class="paramtype">_mutex *&#160;</td>
          <td class="paramname"><em>pmutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases a mutex semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>Pointer to the mutex semaphore to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga455fb88ce04abec31355991e71d32274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_pop_from_xqueue </td>
          <td>(</td>
          <td class="paramtype">_xqueue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function receives a message from a queue. The message is recieved by copy so a buffer adequate size must be provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The handle to the queue from which the message is to be received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The pointer to the buffer into which the received message will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>The maximum amout of time the task should block waiting for a message to receive should the queue be empty at the time of the call. The time is defined in ms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: A message was successfully received from the queue. </dd>
<dd>
-1: No message was received from the queue. </dd></dl>

</div>
</div>
<a class="anchor" id="ga441c8d4a290d6686a80bebb8e41c59f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtw_push_to_xqueue </td>
          <td>(</td>
          <td class="paramtype">_xqueue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function posts a message to the back of a queue. The message is queued by copy, not by reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The handle to the queue on which the message is to be posted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The pointer to the message that is to be placed on the queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>The maximum amout of time the task should block waiting for the space to become available on the queue, should it already be full. The time is defined in ms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: The message was successfully posted. </dd>
<dd>
-1: The message was not posted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09e9d6fa920cee8cfd10c4d7848a5206"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_queue_empty </td>
          <td>(</td>
          <td class="paramtype">_queue *&#160;</td>
          <td class="paramname"><em>pqueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether the queue is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>The handle to the queue to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga1471dbb012522a892cc24edb3d93ba21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_release_wakelock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function indicates that the WLAN does not need to stay on which means can go into power saving mode. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defining configUSE_WAKELOCK_PMU 1 in "FreeRTOSConfig.h" needs to be done before compiling, or this API won't be effective. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a5babf897e2d8284329aeae10c88520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_sec_to_systime </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert seconds to system time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systime</td><td>The seconds to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: The system time that converted by the seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4f01ed4e9126a09d40b702fe3d4525c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_spin_lock </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains a spin lock semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore being taken - obtained when the mutex semaphore was created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gad7267f308d095c538c0d897eaf63035e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_spin_unlock </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases a spin lock semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaef28ab6984d1cf7146af03b748c84454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_spinlock_free </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes the spin lock semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>Pointer to the spin lock semaphore to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga37001b820c09b1a19cf192ded723010d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_spinlock_init </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements a spin lock semaphore by using the existing queue mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the created spin lock semaphore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac6ad8236244e673850643924ce5078de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_spinlock_irqsave </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>irqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function marks the start of a critical code region and obtains a spin lock semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore being taken - obtained when the mutex semaphore was created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">irqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac87035e791ade7f016b995a6de36b113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_spinunlock_irqsave </td>
          <td>(</td>
          <td class="paramtype">_lock *&#160;</td>
          <td class="paramname"><em>plock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_irqL *&#160;</td>
          <td class="paramname"><em>irqL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases a spin lock semaphore and marks the end of a critical code region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plock</td><td>Pointer to the spin lock semaphore to be released. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">irqL</td><td>Pointer to the IRQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga8674586494dd8574362f90ffa8401a54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_systime_to_ms </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>systime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert system time to milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systime</td><td>The system time to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: The milliseconds that converted by the system time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d180388ea1f302c61467595c44e6ab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_systime_to_sec </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>systime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert system time to seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systime</td><td>The system time to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: The seconds that converted by the system time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f70a3abe91f6e1958eabce586f3b704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_thread_enter </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the name of the thread in DBG_INFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac86052516c9cb6c3a4c1bc90e1cca303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_thread_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exits the calling thread. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gabbc6483e7d29c8ab1918784d20724ff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_timerChangePeriod </td>
          <td>(</td>
          <td class="paramtype">_timerHandle&#160;</td>
          <td class="paramname"><em>xTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">osdepTickType&#160;</td>
          <td class="paramname"><em>xNewPeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">osdepTickType&#160;</td>
          <td class="paramname"><em>xBlockTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function changes the period of a timer that was previously created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xTimer</td><td>The handle of the timer that is having its period changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xNewPeriod</td><td>The new period for xTimer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBlockTime</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the change period command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="group___r_t_o_s.html#gabbc6483e7d29c8ab1918784d20724ff6" title="This function changes the period of a timer that was previously created. ">rtw_timerChangePeriod()</a> was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the change period command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. </dd></dl>

</div>
</div>
<a class="anchor" id="gac584192034fe149a89a9c6ff816cb824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_timerHandle rtw_timerCreate </td>
          <td>(</td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>pcTimerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">osdepTickType&#160;</td>
          <td class="paramname"><em>xTimerPeriodInTicks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>uxAutoReload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvTimerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIMER_FUN&#160;</td>
          <td class="paramname"><em>pxCallbackFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a new software timer instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcTimerName</td><td>A text name that is assigned to the timer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xTimerPeriodInTicks</td><td>The timer period which is defined in tick periods. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxAutoReload</td><td>If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvTimerID</td><td>An identifier that is assigned to the timer being created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxCallbackFunction</td><td>The function to call when the timer expires. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the timer is successfully create then a handle to the newly created timer is returned. If the timer cannot be created, then 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga70c7ca6935ebab8b73083de9893afd09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_timerDelete </td>
          <td>(</td>
          <td class="paramtype">_timerHandle&#160;</td>
          <td class="paramname"><em>xTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">osdepTickType&#160;</td>
          <td class="paramname"><em>xBlockTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes a timer that was previously created using rtw_timerCreate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xTimer</td><td>The handle of the timer being deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBlockTime</td><td>Specifies th etime, in ticks, that the calling task should be held in the Blocked State to wait for the delete command to be successfully sent to the timer command queue, should the queue already be full when rtw_timerDelete was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the delete command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a7497759cd3304af7e1ea19fe9d3627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_timerIsTimerActive </td>
          <td>(</td>
          <td class="paramtype">_timerHandle&#160;</td>
          <td class="paramname"><em>xTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function queries a timer to see if it is active or dormant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xTimer</td><td>The timer being queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFALSE will be returned if the timer is dormant. A value other than pdFALSE will be returned if the timer is active. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A timer will be dormant if: 1) It has been created but not started, or 2) It is an expired one-shot timer that has not been restarted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga658aea6db26460a6d9d9b3c4d1f46d21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 rtw_timerStop </td>
          <td>(</td>
          <td class="paramtype">_timerHandle&#160;</td>
          <td class="paramname"><em>xTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">osdepTickType&#160;</td>
          <td class="paramname"><em>xBlockTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops a timer that was previously started. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xTimer</td><td>The handle of the timer being stopped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBlockTime</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the stop command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="group___r_t_o_s.html#ga658aea6db26460a6d9d9b3c4d1f46d21" title="This function stops a timer that was previously started. ">rtw_timerStop()</a> was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the stop command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2a43ba4d719a9577d717e7f047a44eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_udelay_os </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function delays a task for the giving time in microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The amount of time, in microseconds, that the calling task should block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga96ec8c04aa355f3b8f793ab2bd203708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_up_sema </td>
          <td>(</td>
          <td class="paramtype">_sema *&#160;</td>
          <td class="paramname"><em>sema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases the semaphore. This macro must not be used from an ISR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sema</td><td>The semaphore to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d38da5c99a8b7a89e101aee8ffd69b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_up_sema_from_isr </td>
          <td>(</td>
          <td class="paramtype">_sema *&#160;</td>
          <td class="paramname"><em>sema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases the semaphore. This macro can be used from an ISR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sema</td><td>The semaphore to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga32743271ed298e09a4a5d6d55ab8736e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_usleep_os </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function suspends execution of the calling thread for "us" microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The time that the function sleep in microseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gae5627853bef70ebbcccb913093b2a3c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* rtw_vmalloc </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates the virtually contiguous memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The size of memory to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the beginning of the memory </dd></dl>

</div>
</div>
<a class="anchor" id="ga510c5826df487b958b88a22574cc0e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_vmfree </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>pbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees the virtually contiguous memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pbuf</td><td>The pointer to the beginning of the memory to be free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The size of memory allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d259d21a6ce29d0805e8f36f4ddfcc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_wakeup_task </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function wake up a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task stucture which will be waked up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gad1d04350f2daf1172a7c4baf27f023e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtw_yield_os </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function for forcing a context switch. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga40bfe4cd4df674a0b6c8ada337314885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* rtw_zmalloc </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates the memory and the values of the memory are setted to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The size of memory to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the beginning of the memory </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2cd73358028cae5a8c9970bfe41b996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* rtw_zvmalloc </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates the virtually contiguous memory and the values of the memory are setted to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The size of memory to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the beginning of the memory </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
